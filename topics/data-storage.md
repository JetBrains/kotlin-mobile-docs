[//]: # (title: Data storage)
[//]: # (auxiliary-id: Data_storage)

In the world of mobile development, databases are often used for local data storage on client
devices. One of the options for working with databases in Kotlin Mobile Multiplatform (*KMM*)
projects is the **SQLDelight** Library, which generates type-safe Kotlin procedural APIs from SQL
statements for various relational databases. SQLDelight also provides a multiplatform implementation
of the SQLite driver. For a full description of all the features and other details, see the official
[library documentation](https://cashapp.github.io/sqldelight/).

This article discusses ways to connect the SQLDelight Library to a multiplatform project, create a
SQLite database driver, use the SQLDelight generator, and perform basic database queries.

## Connecting and configuring SQLDelight in a KMM project

To connect the SQLDelight plugin to a project, you need to add the plugin's `classpath` to the build
system. To do this, the `buildscript` block, which is usually located inside the `build.gradle` root
script of the project, should look as follows:

```groovy
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath "com.squareup.sqldelight:gradle-plugin:$sql_delight_version"
    }
}
```

You need to substitute `$sql_delight_version` with the required version of the library.

In the Gradle module where you plan to use API generation, you need to connect the plugin itself by
adding this line at the beginning of the `build.gradle` file:

```groovy
apply plugin: 'com.squareup.sqldelight'
```

To connect the SQLite database driver for Android, you need to add the following to the
`dependencies` block of the corresponding source set in the module's `build.gradle`:

```groovy
dependencies {
    implementation "com.squareup.sqldelight:android-driver:$sql_delight_version"
}
```

To connect the SQLite driver for iOS and other native platforms, you need to add the following:

```groovy
dependencies {
    implementation "com.squareup.sqldelight:native-driver:$sql_delight_version"
}
```

To work with database drivers in the common code, a dependency must also be added to the
`commonMain` source set:

```groovy
dependencies {
    implementation "com.squareup.sqldelight:runtime:$sql_delight_version"
}
```

You need to substitute `$sql_delight_version` with the required version of the library.

All SQLDelight generator configurations are performed using Gradle DSL and are added to the
`sqldelight` block of the `build.gradle` script. For example, to create a database named
`AppDatabase` and specify the package name `com.example.db` for the generated Kotlin classes, the
configuration block will look as follows:

```groovy
sqldelight {
    AppDatabase {
        packageName = "com.example.db"
    }
}
```

This SQLDelight configuration will be used for all the code examples listed below.

For information on connecting and configuring the library, see the official
[documentation](https://cashapp.github.io/sqldelight/gradle/).

## Creating an SQLite Driver

Since SQLDelight has a multiplatform implementation of the SQLite driver, it must be created in the
platform code. In the common code of the KMM module, a link to the `SqlDriver` abstract UI is used
to create a database object, the platform implementations of which UI are connected and created
separately.

For the Android platform, the implementation of the SQLite driver is located in the
`AndroidSqliteDriver` class, during whose creation you need to relay a link to `Context` to the
constructor. E.g., creating an SQLite driver for a database named `AppDatabase` may look as follows:

```kotlin
class App : Application() {

    override fun onCreate() {
        super.onCreate()

        val sqlDriver: SqlDriver = AndroidSqliteDriver(
            AppDatabase.Schema, // Link to the database schema generated by SQLDelight
            this,               // Link to Context
            "database.db"       // Arbitrary database name
        )
    }
}
```

Subsequently, the link to the `AndroidSqliteDriver` object can be relayed to the module with the
common code, where the object of the generated `AppDatabase` UI will be created:

```kotlin
val database = AppDatabase(sqlDriver)
```

On native platforms where Kotlin Native is used, the driver implementation takes place in the
`NativeSqliteDriver` class. Therefore, creating an SQLite driver object, for example, for iOS, may
look as follows:

```kotlin
fun createNativeSqliteDriver(): SqlDriver = NativeSqliteDriver(AppDatabase.Schema, "database.db")
```

## Table operations

The main idea of the SQLDelight generator is as follows: a special file with an `.sq ` extension
lists all the required SQL queries to the database, on the basis of which the plugin creates Kotlin
code for the procedural interaction of your program with the DBMS. This eliminates the need for
manual implementation of entity classes and code projecting Kotlin classes onto a relational
database model.

The syntax of the SQLDelight generator allows you to implement all the basic SQLite DBMS commands,
including cascading, indexes, triggers, and others.

Let's look at how to declare and use basic CRUD operations.

### Table creation

Typically, queries to create all the necessary database tables are listed first at the beginning of
the `.sq` file. To create a table, you must use the SQL command `CREATE TABLE`. E.g., declaring a
query to create a table with two fields looks as follows:

```sql
CREATE TABLE Language (
    id INTEGER NOT NULL PRIMARY KEY,
    name TEXT NOT NULL
);
```

As a result of the work of the SQLDelight generator, the Kotlin `Language` UI will be created with
all the specified table fields, which will be used in functions with CRUD operations for this table.

### Deletion from the table

SQL's `DELETE` operator is used to delete rows from database tables. For example, if you need to
make a query to delete all records from the table, then you need to declare the following query in
the `.sq` file:

```sql
deleteAllLanguages:
DELETE FROM Language;
```

The `deleteAllLanguages:` label on the first line indicates for the generator the name of the Kotlin
function that will be automatically declared and created:

```kotlin
fun deleteAllLanguages()
```

To execute a query in the Kotlin code, just write the following:

```kotlin
val database = AppDatabase(sqlDriver)
val appDatabaseQueries: AppDatabaseQueries = database.appDatabaseQueries

fun deleteAllLanguages() {
    appDatabaseQueries.deleteAllLanguages()
}
```

You can use the `WHERE` operator to delete certain rows from a table based on set criteria, e.g.:

```sql
deleteLanguageById:
DELETE FROM Language 
WHERE id = ?;
```

The generator will create the following Kotlin function:

```kotlin
fun deleteLanguageById(id: Long)
```

And similar to the example above, in the application program, the function for executing a query to
delete a specific line will look as follows:

```kotlin
fun deleteLanguageById(id: Long) {
    appDatabaseQueries.deleteLanguageById(id)
}
```

### Insertion into the table

To perform the operation of inserting data into a table, use the SQL command `INSERT`. E.g., a query
to create a function for insertion into a previously declared `Language` table would look as follows:

```sql
insertLanguage:
INSERT INTO Language(id, name)
VALUES(?, ?);
```

The generator will create the following Kotlin function:

```kotlin
fun insertLanguage(id: Long?, name: String)
```

And the code in the project module using this function for inserting a new value into the database
table will look as follows:

```kotlin
data class SystemLanguage(
    val id: Long,
    val name: String
)

val database = AppDatabase(sqlDriver)
val appDatabaseQueries: AppDatabaseQueries = database.appDatabaseQueries

fun insertLanguage(systemLanguage: SystemLanguage) {
    appDatabaseQueries.insertLanguage(systemLanguage.id, systemLanguage.name)
}
```

### Updating

The SQL command `UPDATE` is used to change the values of given fields of specific rows within tables.
E.g., let's add to the `.sq` file a query to change a field of the record with a specific identifier:

```sql
updateLanguageName:
UPDATE Language
SET name = ?
WHERE id = ?;
```

The generator will create the following Kotlin function to execute this query:

```kotlin
fun updateLanguageName(name: String, id: Long)
```

Access to the function generated in the Kotlin code can also be obtained through an object that
stores all database queries. As a result, the complete code of the query to modify the data will
look as follows:

```kotlin
data class SystemLanguage(
    val id: Long,
    val name: String
)

val database = AppDatabase(sqlDriver)
val appDatabaseQueries: AppDatabaseQueries = database.appDatabaseQueries

fun updateLanguageName(id: Long, newName: String) {
    appDatabaseQueries.updateLanguageName(newName, id)
}
```

### Sampling

To select records from tables, use the `SELECT` operator. For example, if you want to excerpt all
the records from a specific table, then you need to add the following in the `.sq` file with all the
queries for a particular database:

```sql
selectAllLanguages:
SELECT * FROM Language;
```

For this SQL query, the generator will create the following functions:

```kotlin
fun selectAllLanguages(): Query<Language>
fun <T : Any> selectAllLanguages(mapper: (id: Long, name: String) -> T): Query<T>
```

As you can see, the second argument in the second `selectLanguageById` function is the `mapper`
lambda, through which you can convert data from the selection into objects `T` of any type. For
example, if you need to transform the query results into entities required for the app's business
logic, then the full Kotlin code will look as follows:

```kotlin
val database = AppDatabase(sqlDriver)
val appDatabaseQueries: AppDatabaseQueries = database.appDatabaseQueries

data class SystemLanguage(
    val id: Long,
    val name: String
)

fun selectAllLanguages(): List<SystemLanguage> {
    return appDatabaseQueries.selectAllLanguages { id: Long, name: String ->
        SystemLanguage(id, name)
    }.executeAsList()
}
```

You can issue queries with selection conditions. E.g., if you want to display a record with a
specific identifier, then the request in the `.sq` file will look as follows:

```sql
selectLanguageById:
SELECT * FROM Language
WHERE id = ?;
```

For this query, the SQLDelight generator will create the following functions:

```kotlin
fun selectLanguageById(id: Long): Query<Language>
fun <T : Any> selectLanguageById(id: Long, mapper: (id: Long, name: String) -> T): Query<T>
```

And similar to the above example, we create a function in the application that will query the
database and convert the result to the object of the required data class:

```kotlin
fun selectById(languageId: Long): SystemLanguage {
    return appDatabaseQueries.selectLanguageById(languageId) { id: Long, name: String ->
        SystemLanguage(id, name)
    }.executeAsOne()
}
```

## Transactions

SQLDelight allows to execute multiple SQL queries in a single transaction. To do this, the
Kotlin-generated interface with queries is inherited from the `Transacter` UI, in which the
`transaction` function for creating transactions is declared. The body of the transaction is formed
in the lambda, which is passed to the `transaction` function. E.g., the function for adding to the
database all the elements of a list with a transaction looks as follows:

```kotlin
fun insertAllLanguages(languages: List<SystemLanguage>) {
    database.appDatabaseQueries.transaction {
        languages.forEach { language ->
            database.appDatabaseQueries.insertLanguage(language.id, language.name)
        }
    }
}
```

# SQLDelight plugin for Android Studio

To simplify working with `.sq` generator files, the library developers suggest using the IntelliJ
plugin for Android Studio, which adds syntax highlighting, code completion, usage search and
expression refactoring function, compiler error display, and much more. For more information, see
the Official [Documentation](https://cashapp.github.io/sqldelight/intellij_plugin/).

To install the plugin in Android Studio, open the plugin browser:
`Preferences` -> `Plugins` -> `Marketplace` and enter `SQLDelight` in search bar.
